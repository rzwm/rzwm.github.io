<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>/post/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 27 Oct 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C&#43;&#43;11高精度计时器类</title>
      <link>/post/2019/10/27/c-11%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E6%97%B6%E5%99%A8%E7%B1%BB/</link>
      <pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/10/27/c-11%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E6%97%B6%E5%99%A8%E7%B1%BB/</guid>
      <description>做图像处理算法时，免不了要测量函数的运行时间。以前我都是使用OpenCV的计时函数cv::getTickCount()和cv::getTickFrequency()，但是这样一来，在不使用OpenCV的项目中就没法用了。
幸好C++11增加了std::chrono库，可以很方便地实现跨平台的时间测量。于是我封装了一个简单的计时器类，这样只要将其简单地保存为头文件，就可以直接包含使用了。
此类当前的计时单位为毫秒，但可以去除/ 1e3从而精确到微秒。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; class Timer { public: Timer() : t1(res::zero()) , t2(res::zero()) { tic(); } ~Timer() {} void tic() { t1 = clock::now(); } void toc(const char* str) { t2 = clock::now(); std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;quot; time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;res&amp;gt;(t2 - t1).count() / 1e3 &amp;lt;&amp;lt; &amp;quot;ms.&amp;quot; &amp;lt;&amp;lt; std::endl; } private: typedef std::chrono::high_resolution_clock clock; typedef std::chrono::microseconds res; clock::time_point t1; clock::time_point t2; };  测试代码如下：
int main() { Timer timer; std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl; timer.</description>
    </item>
    
    <item>
      <title>OpenCV图像取反的快速方法</title>
      <link>/post/2018/06/07/opencv%E5%9B%BE%E5%83%8F%E5%8F%96%E5%8F%8D%E7%9A%84%E5%BF%AB%E9%80%9F%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 07 Jun 2018 21:24:10 +0000</pubDate>
      
      <guid>/post/2018/06/07/opencv%E5%9B%BE%E5%83%8F%E5%8F%96%E5%8F%8D%E7%9A%84%E5%BF%AB%E9%80%9F%E6%96%B9%E6%B3%95/</guid>
      <description>最近在做一个基于去雾的图像亮度增强的算法IBEABFHR，其中用到了图像取反的操作。所谓图像取反，就是将RGB图像的每个像素点(r, g, b)，使用(255 - r, 255 - g, 255 - b)替换。对于灰度图像而言，则是将(g)使用(255 - g)替换。
在OpenCV中要实现此操作，最简单的方法就是遍历每个像素，用255去减，此方法比较粗暴，不再赘述。
更直接地，可以对图像(cv::Mat)整体做减法：
cv::Mat image = cv::imread(&amp;quot;rgb.jpg&amp;quot;); cv::Mat image_inverse = cv::Scalar(255, 255, 255) - image;  也可以使用cv::subtract，效果是一样的:
cv::Mat image = cv::imread(&amp;quot;rgb.jpg&amp;quot;); cv::Mat image_inverse; cv::subtract(cv::Scalar(255, 255, 255), image, image_inverse);  但是我在网上搜索到了更好的方法，那就是使用位运算中的取反操作(~)：
cv::Mat image = cv::imread(&amp;quot;rgb.jpg&amp;quot;); cv::Mat image_inverse = ~image;  原理是，对于一个unsigned char类型的变量c，255 - c与~c是相等的。
此方法在opencv2\core\mat.hpp中声明如下：
CV_EXPORTS MatExpr operator ~(const Mat&amp;amp; m);  需要注意的是，此方法仅对整数型的cv::Mat有效。
一般来说，位运算的速度都是比较快的，事实也是如此，我使用一张4160x2340的图像来做测试，两种方法各运算100次取平均时间，结果如下:
 相减法：14.1862ms 位运算法：11.8158ms  </description>
    </item>
    
  </channel>
</rss>